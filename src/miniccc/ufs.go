// Copyright (2014) Sandia Corporation.
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.

package main

import (
	"io"
	log "minilog"
	"net"
	"ron"
	"sync/atomic"

	"github.com/Harvey-OS/ninep/filesystem"
	"github.com/Harvey-OS/ninep/protocol"
)

var rootFS struct {
	running uint64

	// bidirectional pipes
	toUFS, toRon     io.WriteCloser
	fromUFS, fromRon io.ReadCloser
}

func ufsRunning() bool {
	return atomic.LoadUint64(&rootFS.running) > 0
}

// ufsMessage handles a message from the server and relays it to UFS
func ufsMessage(m *ron.Message) {
	if !client.UFS {
		log.Error("ignoring UFS message")
		return
	}

	switch m.UfsMode {
	case ron.UFS_OPEN:
		if ufsRunning() {
			log.Error("ufs is already running")
			return
		}

		// reader, writer
		rootFS.fromUFS, rootFS.toRon = net.Pipe()
		rootFS.fromRon, rootFS.toUFS = net.Pipe()

		rootFS.running = 1

		go ron.Trunk(rootFS.fromUFS, client.UUID, ufsSendMessage)

		go func() {
			defer atomic.StoreUint64(&rootFS.running, 0)
			defer rootFS.fromUFS.Close()

			log.Info("starting ufs")

			_, err := ufs.NewUFS(func(s *protocol.Server) error {
				s.FromNet, s.ToNet = rootFS.fromRon, rootFS.toRon
				s.Trace = nil // log.Printf
				return nil
			})
			if err != nil {
				log.Error("ufs error: %v", err)
			}
		}()
	case ron.UFS_CLOSE:
		if !ufsRunning() {
			log.Error("ufs not running")
			return
		}

		// start close
		rootFS.toUFS.Close()
	case ron.UFS_DATA:
		if !ufsRunning() {
			log.Error("ufs not running")
			return
		}

		// relay the Tunnel data from ron
		rootFS.toUFS.Write(m.Tunnel)
	}
}

// ufsSendMessage tweaks the message generated by ron.Trunk before calling
// sendMessage.
func ufsSendMessage(m *ron.Message) error {
	m.Type = ron.MESSAGE_UFS
	m.UfsMode = ron.UFS_DATA

	return sendMessage(m)
}
