// Copyright (2014) Sandia Corporation.
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.

package main

import (
	"io"
	log "minilog"
	"net"
	"ron"
	"runtime"

	"github.com/Harvey-OS/ninep/filesystem"
	"github.com/Harvey-OS/ninep/protocol"
)

var rootFS struct {
	running bool

	// bidirectional pipes
	toUFS, toRon     io.WriteCloser
	fromUFS, fromRon io.ReadCloser
}

// ufsMessage handles a message from the server and relays it to UFS
func ufsMessage(m *ron.Message) {
	switch m.UfsMode {
	case ron.UFS_OPEN:
		if rootFS.running {
			log.Error("ufs is already running")
			return
		}

		if runtime.GOOS == "windows" {
			//*ufs.Root = filepath.VolumeName(os.Getenv("SYSTEMROOT")) + "\\"
		}

		//log.Info("starting ufs, root = %v", *ufs.Root)
		rootFS.running = true

		// reader, writer
		rootFS.fromUFS, rootFS.toRon = net.Pipe()
		rootFS.fromRon, rootFS.toUFS = net.Pipe()

		go ron.Trunk(rootFS.fromUFS, client.UUID, ufsSendMessage)

		_, err := ufs.NewUFS(func(s *protocol.Server) error {
			s.FromNet, s.ToNet = rootFS.fromRon, rootFS.toRon
			s.Trace = log.Info
			return nil
		})
		if err != nil {
			log.Error("ufs error: %v", err)
			rootFS.running = false
		}
	case ron.UFS_CLOSE:
		if !rootFS.running {
			log.Error("ufs not running")
			return
		}

		rootFS.running = false
		rootFS.fromRon.Close()
	case ron.UFS_DATA:
		if !rootFS.running {
			log.Error("ufs not running")
			return
		}

		// relay the Tunnel data from ron
		rootFS.toUFS.Write(m.Tunnel)
	}
}

// ufsSendMessage tweaks the message generated by ron.Trunk before calling
// sendMessage.
func ufsSendMessage(m *ron.Message) error {
	m.Type = ron.MESSAGE_UFS
	m.UfsMode = ron.UFS_DATA

	return sendMessage(m)
}
