// Copyright (2014) Sandia Corporation.
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.

package main

import (
	log "minilog"
	"net"
	"os"
	"path/filepath"
	"ron"
	"runtime"

	"github.com/Harvey-OS/ninep/filesystem"
)

var rootFS struct {
	running bool

	fs *ufs.FileServer

	remote, local net.Conn
}

func init() {
	rootPath := "/"
	if runtime.GOOS == "windows" {
		rootPath = filepath.VolumeName(os.Getenv("SYSTEMROOT")) + "\\"
	}

	rootFS.fs = &ufs.FileServer{
		RootPath: rootPath,
		Trace:    log.Info,
	}
}

// ufsMessage handles a message from the server and relays it to UFS
func ufsMessage(m *ron.Message) {
	switch m.UfsMode {
	case ron.UFS_OPEN:
		if rootFS.running {
			log.Error("ufs is already running")
			return
		}

		rootFS.running = true

		rootFS.remote, rootFS.local = net.Pipe()

		go ron.Trunk(rootFS.remote, client.UUID, ufsSendMessage)

		if err := rootFS.fs.Accept(rootFS.local); err != nil {
			log.Error("ufs error: %v", err)
			rootFS.running = false
		}
	case ron.UFS_CLOSE:
		if !rootFS.running {
			log.Error("ufs not running")
			return
		}

		rootFS.running = false
		rootFS.remote.Close()
	case ron.UFS_DATA:
		if !rootFS.running {
			log.Error("ufs not running")
			return
		}

		// relay the Tunnel data from ron
		rootFS.remote.Write(m.Tunnel)
	}
}

// ufsSendMessage tweaks the message generated by ron.Trunk before calling
// sendMessage.
func ufsSendMessage(m *ron.Message) error {
	m.Type = ron.MESSAGE_UFS
	m.UfsMode = ron.UFS_DATA

	return sendMessage(m)
}
