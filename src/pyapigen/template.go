package main

import (
	"text/template"
)

var Template = template.Must(template.New("py").Parse(`'''
Copyright (2017) Sandia Corporation.
Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
the U.S. Government retains certain rights in this software.

Devin Cook <devcook@sandia.gov>
Jon Crussell <jcrusse@sandia.gov>

minimega bindings for Python

**************************************************************************
* THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY THIS FILE BY HAND. *
**************************************************************************

This API uses a Unix domain socket to communicate with a running instance of
minimega. The protocol is documented here, under "Command Port and the Local
Command Flag":

	http://minimega.org/articles/usage.article#TOC_2.2.

This file is automatically generated from the output of "minimega -cli". See
the documentation for genapi.py for details on how to regenerate this file.

This API *should* work for both python2.7 and python3. Please report any issues
to the bug tracker:

	https://github.com/sandia-minimega/minimega/issues
'''


import json
import socket
from threading import Lock


# This is the revision of minimega these bindings were created for and the date
# that the bindings were generated.
__version__ = '{{ .Version }}'
__date__ = '{{ .Date }}'


class Error(Exception): pass


DEFAULT_TIMEOUT = 60


# HAX: python 2/3 hack
try:
	basestring
	def _isstr(obj):
		return isinstance(obj, basestring)
except NameError:
	def _isstr(obj):
		return isinstance(obj, str)


def connect(path='/tmp/minimega/minimega', debug=False):
	'''
	Connect to the minimega instance with UNIX socket at <path> and return
	a new minimega API object.
	'''
	mm = minimega(path)
	mm._debug = debug
	for resps in mm.version():
		for resp in resps['Resp']:
			if __version__ not in resp['Response']:
				print('WARNING: API was built using a different version of minimega')
	return mm


def raise_error(v):
	'''
	raise_error walks the response from minimega and raises an error for any
	non-empty errors.
	'''
	for resps in v:
		for resp in resps['Resp']:
			if resp['Error'] != '':
				raise minimega.Error(resp['Error'])


def print_rows(v):
	'''
	print_rows walks the response from minimega and prints all tabular data.
	Raises an error for any non-empty errors.
	'''
	for resps in v:
		for resp in resps['Resp']:
			if resp['Error'] != '':
				raise minimega.Error(resp['Error'])
			for row in resp['Tabular'] or []:
				print row


class minimega:
	'''
	This class communicates with a running instance of minimega using a Unix
	domain socket.

	Each minimega command can be called from this object, and the response will
	be returned unless an Exception is thrown.
	'''

	def __init__(self, path, timeout=None):
		'''Connects to the minimega instance with Unix socket at <path>.'''
		self.mm = self
		self.lock = Lock()
		self._debug = False
		self._path = path
		self._timeout = timeout
		self._socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
		self._socket.settimeout(timeout if timeout != None else DEFAULT_TIMEOUT)
		self._socket.connect(path)


	def _get_response(self):
		'''
		_get_response reads a single response from minimega
		'''

		msg = ''
		more = self._socket.recv(1).decode('utf-8')
		response = None
		while response is None and more:
			msg += more
			# want to read a full JSON object, and not run json.loads for
			# every byte read
			if more != '}':
				more = self._socket.recv(1).decode('utf-8')
				continue

			try:
				response = json.loads(msg)
			except ValueError as e:
				if self._debug:
					print(e)
			more = self._socket.recv(1).decode('utf-8')

		if not response:
			raise Error('Expected response, socket closed')

		if self._debug:
			print('[debug] response: ' + str(response))
		return response


	def _run(self, *args):
		'''
		_run sends a command to minimega and returns a generator for all the
		responses.
		'''
		msg = json.dumps({'Command': ' '.join([str(v) for v in args if v])})

		if self._debug:
			print('[debug] sending cmd: ' + msg)

		with self.lock:
			if len(msg) != self._socket.send(msg.encode('utf-8')):
				raise Error('failed to write message to minimega')

			response = self._get_response()
			while response['More']:
				yield response
				response = self._get_response()

			yield response


	{{ range $cmd := .Commands }}
	def {{ $cmd.Name }}(self,
	{{- range $arg := $cmd.Args -}}
		{{ $arg.Name }}{{ if $arg.Optional }}=None{{ end }},
	{{- end }}):
		'''
Variants:
	{{- range $i, $v := $cmd.Variants }}
	{{ $v.Pattern }}
	{{- end }}

{{ $cmd.Help }}
		'''

	{{- range $i, $v := $cmd.Variants }}
		# {{ $v.Pattern }}
		if {{ range $j, $arg := $v.Args -}}
			{{ if (gt $j 0) }} and {{ end -}}
				{{ $arg.Name }} != None
		{{- else -}}
		True
		{{- end }}:

		{{- range $arg := $v.Args }}
			{{- if gt (len $arg.Options) 1 }}
			# Validate that choice was valid for {{ $arg.Name }}
			if {{ $arg.Name }} not in [{{ range $o := $arg.Options }}{{ printf "%q" $o}},{{end}}]:
				raise ValueError("invalid value for {{ $arg.Name }}")
				{{- end -}}
			{{- end }}
			return self._run({{ $v.Template }})
	{{ end }}

		# didn't match any variant
		raise ValueError("invalid argument combination")
	{{ end }}
`))
