meshage

// TODO: what happens when non-unique nodes show up? Can you poison the network this way?

Meshage is a fully distributed, mesh based, message passing protocol. It supports completely decentralized message passing, both to a set of nodes as well as broadcast. Meshage is design for resiliency, and automatically updates routes and topologies when nodes in the mesh fail. Meshage automatically maintains density health - as nodes leave the mesh, adjacent nodes will connect to others in the mesh to maintain a minimum degree for resiliency. 

Meshage is decentralized - Any node in the mesh is capable of initiating and receiving messages of any type. This also means that any node is capable of issuing control messages that affect the topology of the mesh.

Meshage is secure and resilient - All messages are signed and encrypted by the sender to guarantee authenticity and integrity. Nodes on the network store public keys of trusted agents, who may send messages signed and encrypted with a corresponding private key. This is generally done by the end user. Compromised nodes on the mesh that attempt denial of service through discarding messages routed through them are automatically removed from the network by neighbor nodes.  

typical structure and API

A typical message structure and API is given below, implementations may vary from this structure to fit specific needs.

const (
        SET = iota
        BROADCAST
        UNION
        INTERSECTION
        MESSAGE
        ACK
        NACK
)

// errors
const (
        UNROUTABLE = iota // host is/was on the network, but is now unroutable
        RETRY_LIMIT // attempt to send failed too many times
        INVALID_RECIPIENT // recipient node is not on the network
)

// a Node object contains the network information for a given node. Creating a Node object with a non-zero degree will cause it to begin broadcasting for connections automatically.
type Node struct {
        name string // node name. Must be unique on a network.
        degree uint // degree for this node, set to 0 to force node to not broadcast
        mesh map[string][]string // adjacency list for the known topology for this node
        
        set_sequences map[string]uint64 // set sequence IDs for each node, including this node
        broadcast_sequences map[string]uint64 // broadcast sequence IDs for each node, including this node

        routes map[string]string // one-hop routes for every node on the network, including this node

        receive chan interface{} // channel of incoming message bodies. A program will read this channel for incoming messages to this node
}

type Message struct {
        Message_type int // set or broadcast
        Recipients []string // list of recipients if message_type = MESSAGE_SET, undefined if broadcast
        Source string // name of source node
        CurrentRoute []string // list of hops for an in-flight message
        ID uint64 // sequence id

        Command int // union, intersection, message, ack
        Network mesh // mesh to union/intersection, undefined if not union/intersection

        Body interface{} // message body
}

// NewNode returns a new node and receiver channel with a given name and degree. If degree is non-zero, the node will automatically begin broadcasting for connections
func NewNode(name string, degree uint) (Node, chan interface{})

// Degree sets the degree for a given node. Setting degree == 0 will cause the node to stop broadcasting for connections.
func (n *Node) Degree(d uint) 

// Dial connects a node to another, regardless of degree. Returned error is nil if successful.
func (n *Node) Dial(addr string) error

// Send a message according to the parameters set in the message. Error is nil if successful. Set messages will block until the message is acknowledged, or receives an error. Broadcast messages will return immediately. 
// Users will generally use the Set and Broadcast methods instead of Send.
func (n *Node) Send(m Message) error

// Send a set message heartbeat to all nodes and block until all ACKs have been received. 
func (n *Node) Heartbeat() error

// Set sends a set message to a list of recipients. Set blocks until all recipients have acknowledged the message, or returns a non-nil error.
func (n *Node) Set(recipients []string, body interface{}) error

// Broadcast sends a broadcast message to all connected nodes. Broadcast does not block.
func (n *Node) Broadcast(body interface{})

connecting

Clients can connect to the mesh in two ways - By direct connection to another listening client, and by broadcasting an eligibility to be connected to. The programmer may force a node to attempt a connection to another via the Dial API. 

On a network that supports it, UDP is the preferred way to broadcast eligibility for connection. Other cases are implementation specific. When a broadcast is responded to the connection behaves like a normal direct connection from the responder to the broadcaster. 

Direct connections follow a simple handshake that both establishes the legitimacy of the connection as well as communicates the network details of the known mesh to both nodes. 

1) Node A connects to a listening node B
2) If Node B does not wish to keep the connection, is simply disconnects. If Node B does wish to keep the connection, it responds with it's entire known network, not including the new connection from Node A to B.
3) Node A merges the network topology from Node B with its own, adds the new connection from Node A to B, and then broadcasts the new network to all connected nodes on the mesh with a MESH_UNION command. 

disconnecting

Nodes may voluntarily disconnect by issuing a broadcast MESH_INTERSECTION command with their own node's connections. Nodes directly connected to the disconnecting node will drop their connection to that node. On success, the disconnecting node will be left with no connections. Nodes that involuntarily disconnect (network outage, crash) are left in the mesh until either a message transfer is attempted via that node or some other indication of that nodes failure. Connected neighbor nodes announce MESH_INTERSECTION of that node on their connection.

routing

Each node calculates the routes from themselves to all other nodes in the graph. Routes are calculated using Dijkstra's Algorithm. All routes are recalculated on any events that update the topology. Messages that are passed to other nodes do not require the route information. Instead, nodes receiving a message not intended for them look up the route for that node and pass the message along to the next node on the route.

graph degree

The mesh always attempts to stay connected at degree D, which is set by the programmer and may be changed at runtime. Nodes on the mesh attempt to maintain a local degree D by broadcasting for new connections until D is met. If a broadcast is sent and no response is given, the node performs an exponential backoff (rand(2^c - 1) * backoff time) wait and then attempts to reconnect again. Upon successful connection, or when the degree D is met the backoff coefficient C is reset to 0. The maximum backoff coefficient is implementation specific.

Nodes will attempt to connect to other nodes in the graph via broadcast (typically UDP broadcast, but this is implementation specific). Nodes make connection attempts whenever their degree is less than the specified degree D. This occurs at startup when no nodes are connected, and when connections are lost due to other nodes leaving the mesh. 

Setting the degree too high will create additional traffic on the network if the degree cannot be satisfied. 

message passing

There are two ways a node may pass a message to other nodes: set messaging and broadcast messaging. 

Set messaging involves sending a sequenced message to one or more nodes via one or more routes. The 'set' is specified in the message metadata as a list of recipient nodes. If two nodes on the list follow different routes from a given node, the message is duplicated down all routes necessary. For example, if Node A wishes to send a message to Nodes C and D, and both C and D are connected to A via node B as in:

         --C
A -- B --|
         --D

Node A sends a message with C and D in the set list to Node B. Node B repeats the message to C and D. This allows message traffic to be reduced along like routes.

Set messages are sequenced by the source node. The source node increments a 64-bit counter for its own sequence ID for every message sent. All nodes keep local copies of the sequence count for all nodes on the network (so for a network of 100 nodes, every node must keep 200 counters - one for set messages, and one for broadcast messages for each node).

Nodes that receive a message (whether or not it is the recipient or a hop on a route) check the sequence ID of the message and their local copy of the counter for the source node. If the sequence ID is greater than the local copy, the local copy is updated to that of the message sequence ID and the message is either passed on or consumed. If the sequence ID is equal to or less than the local copy, then the message is a reflection (or some error has occurred), and the message is dropped. This allows a source node to send a message along multiple routes (i.e. for resiliency). The first message to arrive will be consumed, and the next will be dropped. This also protects against reflections.

Set messages generate ACK messages from the recipient. ACK messages should be sent by the recipient before processing the message, as it is simply an acknowledgement of receipt of the message, not a response to the message content. ACK messages are normal set messages with a single recipient (the source node of the original message), sent as ACK type, and the original sequence ID of the source message as the body. ACK messages are not responded to (unless a route fails, see failure response below). The source node must consume the ACK before sending any other messages. This implies that only ONE set message from a given source node may be in-flight at any given time. This is necessary to avoid sequence ID race conditions. Other nodes may issue messages in parallel, as each node maintains their own sequence counters.

Broadcast messaging involves the source node sending a sequenced message to all neighbor nodes. Neighbor nodes repeat the message to all of their neighbor nodes, except the node that sent the message, and so on. Depending on the topology, there may be significant reflection. This is by design and allows for resilient receipt of messages in densely connected graphs. Broadcast messages are sequenced with a 64-bit sequence ID, that increases for every broadcast message sent by that node. Every node keeps a record of sequence ID values for every connected node in the network. When a message with a sequence ID greater than currently recorded, the sequence ID is set to the value of the message, and the message is sent to neighbor nodes. When a message with equal or less sequence ID is received, the message is dropped. This reduces reflection to one re-broadcast per connected node. Sequence IDs must always increase and are set by the source node.  

A set message with all connected nodes is different than a broadcast message in that a broadcast message does not generate an acknowledgement of receipt of the message by any recipients.

routing failure and recovery

Routes are updated only when nodes join or leave the network, and on routing failure. A routing failure occurs when a message is sent along a route and fails to reach a hop. Failure to reach a hop is implementation specific (for example a timeout or failure to receive a lower level ACK on each hop on the route). When a route fails, the sending node (the node that discovers the failure, not necessarily the source node) announces the failure by sending a broadcast message with type INTERSECTION, removing the connection from that node to the failed one. It then disconnects from that node, and sends a NACK to the source node with the sequence ID and list of successful hops up to the failure to the source node. 

Having received the INTERSECTION notice (which rebuilds the routes) and the NACK message, the source node then must resend the original message down a new route.

In the event that a message fails to be delivered and the new routes indicate that the recipient node is unroutable, an UNROUTABLE error is returned to the calling function. 

Implementations may optionally enforce a retry limit for messages that fail to deliver (which applies to all types of messages, including ACK/NACK. 

Nodes that lose all connections will attempt to reconnect to any listing nodes via broadcast, as the local degree for that node has dropped to 0.

common control functions

Although not part of the specification proper, these mechanisms may be provided by an implementation for convenience.

'heartbeat' - A heartbeat message is a set message sent to all nodes on the network. Since a set message generates ACKs and can cause the network to trim failed connections and heal, this type of message effectively generates a health response from the entire network. 
