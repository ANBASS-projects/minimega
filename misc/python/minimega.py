'''
Copyright (2015) Sandia Corporation.
Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
the U.S. Government retains certain rights in this software.

Devin Cook <devcook@sandia.gov>

Minimega bindings for Python

**************************************************************************
* THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY THIS FILE BY HAND. *
**************************************************************************

This API uses a Unix domain socket to communicate with a running instance of
minimega. The protocol is documented here:
https://code.google.com/p/minimega/wiki/UserGuide#Command_Port_and_the_Local_Command_Flag

This file is automatically generated from the output of "minimega -cli". See
the documentation for genapi.py for details on how to regenerate this file.

This API *should* work for both python2.7 and python3. Please report any issues
to the bug tracker:
https://code.google.com/p/minimega/issues/list
'''


import json
import socket
from threading import Lock


# This version is specific to the python API. It is not indicative of the
#  versions of minimega that it can talk with.
__version__ = '2.0.dev0'


class Error(Exception): pass
class ValidationError(Error): pass


DEFAULT_TIMEOUT = 60
MSG_BLOCK_SIZE = 4096

# HAX: python 2/3 hack
try:
    def _isstr(obj):
        return isinstance(obj, basestr)
except NameError:
    def _isstr(obj):
        return isinstance(obj, str)


def connect(path):
    '''
    Connect to the minimega instance with UNIX socket at <path> and return
    a new minimega API object.
    '''
    return minimega(path)


class Command:
    pass


class minimega:
    '''
    This class communicates with a running instance of minimega using a Unix
    domain socket. The protocol is specified here:
    https://code.google.com/p/minimega/wiki/UserGuide#Command_Port_and_the_Local_Command_Flag

    Each minimega command can be called from this object, and the response will
    be returned unless an Exception is thrown.
    '''

    def __init__(self, path, timeout=None):
        '''Connects to the minimega instance with Unix socket at <path>.'''
        self.lock = Lock()
        self._debug = False
        self._path = path
        self._timeout = timeout
        self._socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self._socket.settimeout(timeout if timeout != None else DEFAULT_TIMEOUT)
        self._socket.connect(path)

    def _reconnect(self):
        try:
            self._socket.close()
        except:
            pass

        self.__init__(self._path, self._timeout)

    def _send(self, cmd, *args):
        msg = json.dumps({'Original': cmd + ' ' + ' '.join(map(str, args))},
                         separators=(',', ':'))
        if self._debug:
            print('[debug] sending cmd: ' + msg)
        with self.lock:
            if len(msg) != self._socket.send(msg.encode('utf-8')):
                raise Error('failed to write message to minimega')

            msg = ''
            more = self._socket.recv(MSG_BLOCK_SIZE).decode('utf-8')
            response = None
            while response is None and more:
                msg += more
                try:
                    response = json.loads(msg)
                except ValueError as e:
                    if self._debug:
                        print(e)
                    more = self._socket.recv(MSG_BLOCK_SIZE).decode('utf-8')

            if not msg:
                raise Error('Expected response, socket closed')

            if self._debug:
                print('[debug] response: ' + msg)
            if response['Resp'][0]['Error']:
                raise Error(response['Resp'][0]['Error'])

            return response['Resp']


    
    def read(self, *args):
        '''Read a command file and execute it. This has the same behavior as if you typed
the file in manually.'''
        #validate the args
        candidates = [[{'text': 'file', 'type': 'stringItem', 'optional': False, 'key': 'file'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('read', *args)
        raise ValidationError('could not understand command', args)
    

    
    def viz(self, *args):
        '''Output the current experiment topology as a graphviz readable 'dot' file.'''
        #validate the args
        candidates = [[{'text': 'filename', 'type': 'stringItem', 'optional': False, 'key': 'filename'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('viz', *args)
        raise ValidationError('could not understand command', args)
    

    
    def host(self, *args):
        '''report information about the host'''
        #validate the args
        candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['name'], 'text': 'name,'}], [{'type': 'choiceItem', 'optional': True, 'options': ['memused'], 'text': 'memused,'}], [{'type': 'choiceItem', 'optional': True, 'options': ['memtotal'], 'text': 'memtotal,'}], [{'type': 'choiceItem', 'optional': True, 'options': ['load'], 'text': 'load,'}], [{'type': 'choiceItem', 'optional': True, 'options': ['bandwidth'], 'text': 'bandwidth,'}], [{'type': 'choiceItem', 'optional': True, 'options': ['cpus'], 'text': 'cpus,'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('host', *args)
        raise ValidationError('could not understand command', args)
    

    
    def headers(self, *args):
        '''Enable or disable headers for tabular data.'''
        #validate the args
        candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['true', 'false'], 'text': 'true,false'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('.headers', *args)
        raise ValidationError('could not understand command', args)
    

    
    def web(self, *args):
        '''Launch a webserver that allows you to browse the connected minimega hosts and
VMs, and connect to any VM in the pool.

This command requires access to an installation of novnc. By default minimega
looks in 'pwd'/misc/novnc. To set a different path, invoke:

	web novnc <path to novnc>

To start the webserver on a specific port, issue the web command with the port:

	web 7000

9001 is the default port.'''
        #validate the args
        candidates = [[{'text': 'port', 'type': 'stringItem', 'optional': True, 'key': 'port'}], [{'type': 'literalItem', 'optional': False, 'text': 'novnc'}, {'text': 'path to novnc', 'type': 'stringItem', 'optional': False, 'key': 'path'}, {'text': 'port', 'type': 'stringItem', 'optional': True, 'key': 'port'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('web', *args)
        raise ValidationError('could not understand command', args)
    

    
    def annotate(self, *args):
        '''Enable or disable hostname annotation for responses.'''
        #validate the args
        candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['true', 'false'], 'text': 'true,false'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('.annotate', *args)
        raise ValidationError('could not understand command', args)
    

    
    def vyatta(self, *args):
        '''Define and write out vyatta router floppy disk images.

vyatta takes a number of subcommands:

- 'dhcp': Add DHCP service to a particular network by specifying the network,
default gateway, and start and stop addresses. For example, to serve dhcp on
10.0.0.0/24, with a default gateway of 10.0.0.1:

	vyatta dhcp add 10.0.0.0/24 10.0.0.1 10.0.0.2 10.0.0.254

An optional DNS argument can be used to override the nameserver. For example,
to do the same as above with a nameserver of 8.8.8.8:

	vyatta dhcp add 10.0.0.0/24 10.0.0.1 10.0.0.2 10.0.0.254 8.8.8.8

Optionally, you can specify "none" for the default gateway.

- 'interfaces': Add IPv4 addresses using CIDR notation. Optionally, 'dhcp' or
'none' may be specified. The order specified matches the order of VLANs used in
vm_net. This number of arguments must either be 0 or equal to the number of
arguments in 'interfaces6' For example:

	vyatta interfaces 10.0.0.1/24 dhcp

- 'interfaces6': Add IPv6 addresses similar to 'interfaces'. The number of
arguments must either be 0 or equal to the number of arguments in 'interfaces'.

- 'rad': Enable router advertisements for IPv6. Valid arguments are IPv6
prefixes or "none". Order matches that of interfaces6. For example:

	vyatta rad 2001::/64 2002::/64

- 'ospf': Route networks using OSPF. For example:

	vyatta ospf 10.0.0.0/24 12.0.0.0/24

- 'ospf3': Route IPv6 interfaces using OSPF3. For example:

	vyatta ospf3 eth0 eth1

- 'routes': Set static routes. Routes are specified as

	<network>,<next-hop> ...

For example:

	vyatta routes 2001::0/64,123::1 10.0.0.0/24,12.0.0.1

- 'config': Override all other options and use a specified file as the config
file. For example: vyatta config /tmp/myconfig.boot

- 'write': Write the current configuration to file. If a filename is omitted, a
random filename will be used and the file placed in the path specified by the
-filepath flag. The filename will be returned.'''
        #validate the args
        candidates = [[], [{'type': 'choiceItem', 'optional': False, 'options': ['dhcp'], 'text': 'dhcp,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['dhcp'], 'text': 'dhcp,'}, {'type': 'literalItem', 'optional': False, 'text': 'add'}, {'text': 'network', 'type': 'stringItem', 'optional': False, 'key': 'network'}, {'text': 'gateway or none', 'type': 'stringItem', 'optional': False, 'key': 'gateway'}, {'text': 'low dhcp range', 'type': 'stringItem', 'optional': False, 'key': 'low'}, {'text': 'high dhcp range', 'type': 'stringItem', 'optional': False, 'key': 'high'}, {'text': 'dns server', 'type': 'stringItem', 'optional': True, 'key': 'dns'}], [{'type': 'choiceItem', 'optional': False, 'options': ['dhcp'], 'text': 'dhcp,'}, {'type': 'literalItem', 'optional': False, 'text': 'delete'}, {'text': 'network', 'type': 'stringItem', 'optional': False, 'key': 'network'}], [{'type': 'choiceItem', 'optional': False, 'options': ['interfaces'], 'text': 'interfaces,'}, {'text': 'net A.B.C.D/MASK or dhcp or none', 'type': 'listItem', 'optional': True, 'key': 'net'}], [{'type': 'choiceItem', 'optional': False, 'options': ['interfaces6'], 'text': 'interfaces6,'}, {'text': 'net IPv6 address/MASK or none', 'type': 'listItem', 'optional': True, 'key': 'net'}], [{'type': 'choiceItem', 'optional': False, 'options': ['rad'], 'text': 'rad,'}, {'text': 'prefix', 'type': 'listItem', 'optional': True, 'key': 'prefix'}], [{'type': 'choiceItem', 'optional': False, 'options': ['ospf'], 'text': 'ospf,'}, {'text': 'network', 'type': 'listItem', 'optional': True, 'key': 'network'}], [{'type': 'choiceItem', 'optional': False, 'options': ['ospf3'], 'text': 'ospf3,'}, {'text': 'network', 'type': 'listItem', 'optional': True, 'key': 'network'}], [{'type': 'choiceItem', 'optional': False, 'options': ['routes'], 'text': 'routes,'}, {'text': 'network and next-hop separated by comma', 'type': 'listItem', 'optional': True, 'key': 'network'}], [{'type': 'choiceItem', 'optional': False, 'options': ['config'], 'text': 'config,'}, {'text': 'filename', 'type': 'stringItem', 'optional': True, 'key': 'filename'}], [{'type': 'choiceItem', 'optional': False, 'options': ['write'], 'text': 'write,'}, {'text': 'filename', 'type': 'stringItem', 'optional': True, 'key': 'filename'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('vyatta', *args)
        raise ValidationError('could not understand command', args)
    

    
    class log:
    
    
        def stderr(self, *args):
            '''enable or disable logging to stderr'''
            #validate the args
            candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['true', 'false'], 'text': 'true,false'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('log stderr', *args)
            raise ValidationError('could not understand command', args)
    

    
        def file(self, *args):
            '''Log to a file. To disable file logging, call "clear log file".'''
            #validate the args
            candidates = [[{'text': 'file', 'type': 'stringItem', 'optional': True, 'key': 'file'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('log file', *args)
            raise ValidationError('could not understand command', args)
    

    
        def level(self, *args):
            '''Set the log level to one of [debug, info, warn, error, fatal]. Log levels
inherit lower levels, so setting the level to error will also log fatal, and
setting the mode to debug will log everything.'''
            #validate the args
            candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['debug', 'info', 'warn', 'error', 'fatal'], 'text': 'debug,info,warn,error,fatal'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('log level', *args)
            raise ValidationError('could not understand command', args)
    

    

    
    def json(self, *args):
        '''Enable or disable JSON mode. Enabling JSON mode disables CSV mode, if enabled.'''
        #validate the args
        candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['true', 'false'], 'text': 'true,false'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('.json', *args)
        raise ValidationError('could not understand command', args)
    

    
    def check(self, *args):
        '''Minimega maintains a list of external packages that it depends on, such as
qemu. Calling check will attempt to find each of these executables in the
avaiable path, and returns an error on the first one not found.'''
        #validate the args
        candidates = [[]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('check', *args)
        raise ValidationError('could not understand command', args)
    

    
    def history(self, *args):
        '''show command history'''
        #validate the args
        candidates = [[]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('history', *args)
        raise ValidationError('could not understand command', args)
    

    
    def dnsmasq(self, *args):
        '''Start a dhcp/dns server on a specified IP with a specified range.  For example,
to start a DHCP server on IP 10.0.0.1 serving the range 10.0.0.2 -
10.0.254.254:

	dnsmasq start 10.0.0.1 10.0.0.2 10.0.254.254

To start only a from a config file:

	dnsmasq start /path/to/config

To list running dnsmasq servers, invoke dnsmasq with no arguments.  To kill a
running dnsmasq server, specify its ID from the list of running servers. For
example, to kill dnsmasq server 2:

	dnsmasq kill 2

To kill all running dnsmasq servers, pass all as the ID:

	dnsmasq kill all

dnsmasq will provide DNS service from the host, as well as from /etc/hosts. You
can specify an additional config file for dnsmasq by providing a file as an
additional argument.

	dnsmasq start 10.0.0.1 10.0.0.2 10.0.254.254 /tmp/dnsmasq-extra.conf

NOTE: If specifying an additional config file, you must provide the full path
to the file.'''
        #validate the args
        candidates = [[], [{'type': 'literalItem', 'optional': False, 'text': 'start'}, {'text': 'listen address', 'type': 'stringItem', 'optional': False, 'key': 'listen'}, {'text': 'low dhcp range', 'type': 'stringItem', 'optional': False, 'key': 'low'}, {'text': 'high dhcp range', 'type': 'stringItem', 'optional': False, 'key': 'high'}, {'text': 'config', 'type': 'stringItem', 'optional': True, 'key': 'config'}], [{'type': 'literalItem', 'optional': False, 'text': 'start'}, {'text': 'config', 'type': 'stringItem', 'optional': False, 'key': 'config'}], [{'type': 'literalItem', 'optional': False, 'text': 'kill'}, {'text': 'id or all', 'type': 'stringItem', 'optional': False, 'key': 'id'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('dnsmasq', *args)
        raise ValidationError('could not understand command', args)
    

    
    def tap(self, *args):
        '''Control host taps on a named vlan for communicating between a host and any VMs
on that vlan.

Calling tap with no arguments will list all created taps.

To create a tap on a particular vlan, invoke tap with the create command:

	tap create <vlan>

For example, to create a host tap with ip and netmask 10.0.0.1/24 on VLAN 5:

	tap create 5 ip 10.0.0.1/24

Optionally, you can specify the bridge to create the host tap on:

	tap create <vlan> bridge <bridge> ip <ip>

You can also optionally specify the tap name, otherwise the tap will be in the
form of mega_tapX.

Additionally, you can bring the tap up with DHCP by using "dhcp" instead of a
ip/netmask:

	tap create 5 dhcp

To delete a host tap, use the delete command and tap name from the tap list:

	tap delete <id>

To delete all host taps, use id all, or 'clear tap':

	tap delete all'''
        #validate the args
        candidates = [[], [{'type': 'choiceItem', 'optional': False, 'options': ['create'], 'text': 'create,'}, {'text': 'vlan', 'type': 'stringItem', 'optional': False, 'key': 'vlan'}, {'text': 'tap name', 'type': 'stringItem', 'optional': True, 'key': 'tap'}], [{'type': 'choiceItem', 'optional': False, 'options': ['create'], 'text': 'create,'}, {'text': 'vlan', 'type': 'stringItem', 'optional': False, 'key': 'vlan'}, {'type': 'literalItem', 'optional': False, 'text': 'bridge'}, {'text': 'bridge', 'type': 'stringItem', 'optional': False, 'key': 'bridge'}, {'text': 'tap name', 'type': 'stringItem', 'optional': True, 'key': 'tap'}], [{'type': 'choiceItem', 'optional': False, 'options': ['create'], 'text': 'create,'}, {'text': 'vlan', 'type': 'stringItem', 'optional': False, 'key': 'vlan'}, {'type': 'choiceItem', 'optional': False, 'options': ['dhcp'], 'text': 'dhcp,'}, {'text': 'tap name', 'type': 'stringItem', 'optional': True, 'key': 'tap'}], [{'type': 'choiceItem', 'optional': False, 'options': ['create'], 'text': 'create,'}, {'text': 'vlan', 'type': 'stringItem', 'optional': False, 'key': 'vlan'}, {'type': 'literalItem', 'optional': False, 'text': 'ip'}, {'text': 'ip', 'type': 'stringItem', 'optional': False, 'key': 'ip'}, {'text': 'tap name', 'type': 'stringItem', 'optional': True, 'key': 'tap'}], [{'type': 'choiceItem', 'optional': False, 'options': ['create'], 'text': 'create,'}, {'text': 'vlan', 'type': 'stringItem', 'optional': False, 'key': 'vlan'}, {'type': 'literalItem', 'optional': False, 'text': 'bridge'}, {'text': 'bridge', 'type': 'stringItem', 'optional': False, 'key': 'bridge'}, {'type': 'choiceItem', 'optional': False, 'options': ['dhcp'], 'text': 'dhcp,'}, {'text': 'tap name', 'type': 'stringItem', 'optional': True, 'key': 'tap'}], [{'type': 'choiceItem', 'optional': False, 'options': ['create'], 'text': 'create,'}, {'text': 'vlan', 'type': 'stringItem', 'optional': False, 'key': 'vlan'}, {'type': 'literalItem', 'optional': False, 'text': 'bridge'}, {'text': 'bridge', 'type': 'stringItem', 'optional': False, 'key': 'bridge'}, {'type': 'literalItem', 'optional': False, 'text': 'ip'}, {'text': 'ip', 'type': 'stringItem', 'optional': False, 'key': 'ip'}, {'text': 'tap name', 'type': 'stringItem', 'optional': True, 'key': 'tap'}], [{'type': 'choiceItem', 'optional': False, 'options': ['delete'], 'text': 'delete,'}, {'text': 'id or all', 'type': 'stringItem', 'optional': False, 'key': 'id'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('tap', *args)
        raise ValidationError('could not understand command', args)
    

    
    def optimize(self, *args):
        '''Enable or disable several virtualization optimizations, including Kernel
Samepage Merging, CPU affinity for VMs, and the use of hugepages.

To enable/disable Kernel Samepage Merging (KSM):
	optimize ksm [true,false]

To enable hugepage support:
	optimize hugepages </path/to/hugepages_mount>

To disable hugepage support:
	optimize hugepages ""

To enable/disable CPU affinity support:
	optimize affinity [true,false]

To set a CPU set filter for the affinity scheduler, for example (to use only
CPUs 1, 2-20):
	optimize affinity filter [1,2-20]

To clear a CPU set filter:
	optimize affinity filter

To view current CPU affinity mappings:
	optimize affinity

To disable all optimizations see "clear optimize".'''
        #validate the args
        candidates = [[], [{'type': 'choiceItem', 'optional': False, 'options': ['ksm'], 'text': 'ksm,'}, {'type': 'choiceItem', 'optional': True, 'options': ['true', 'false'], 'text': 'true,false'}], [{'type': 'choiceItem', 'optional': False, 'options': ['hugepages'], 'text': 'hugepages,'}, {'text': 'path', 'type': 'stringItem', 'optional': True, 'key': 'path'}], [{'type': 'choiceItem', 'optional': False, 'options': ['affinity'], 'text': 'affinity,'}, {'type': 'choiceItem', 'optional': True, 'options': ['true', 'false'], 'text': 'true,false'}], [{'type': 'choiceItem', 'optional': False, 'options': ['affinity'], 'text': 'affinity,'}, {'type': 'literalItem', 'optional': False, 'text': 'filter'}, {'text': 'filter', 'type': 'stringItem', 'optional': False, 'key': 'filter'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('optimize', *args)
        raise ValidationError('could not understand command', args)
    

    
    def compress(self, *args):
        '''Enable or disable output compression of like output from multiple responses.
For example, if you executed a command using mesh, such as:

	mesh send node[0-9] version

You would expect to get the same minimega version for all 10 nodes. Rather than
print out the same version 10 times, minicli with compression enabled would print:

	node[0-9]: minimega <version>

Assuming that all the minimega instances are running the same version. If one node was running
a different version or has an error, compression is still useful:

	node[0-4,6-9]: minimega <version>
	node5: minimega <version>

Or,

	node[0-3,9]: minimega <version>
	node[4-8]: Error: <error>

Compression is not applied when the output mode is JSON.'''
        #validate the args
        candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['true', 'false'], 'text': 'true,false'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('.compress', *args)
        raise ValidationError('could not understand command', args)
    

    
    def write(self, *args):
        '''Write the command history to file. This is useful for handcrafting configs on
the minimega command line and then saving them for later use. Args that failed,
as well as some commands that do not impact the VM state, such as 'help', do
not get recorded.'''
        #validate the args
        candidates = [[{'text': 'file', 'type': 'stringItem', 'optional': False, 'key': 'file'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('write', *args)
        raise ValidationError('could not understand command', args)
    

    
    class clear:
    
    
        def optimize(self, *args):
            '''Resets state for virtualization optimizations. See "help optimize" for more
information.'''
            #validate the args
            candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['affinity'], 'text': 'affinity,'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('clear optimize', *args)
            raise ValidationError('could not understand command', args)
    

    
        def vnc(self, *args):
            '''Resets the state for VNC recordings. See "help vnc" for more information.'''
            #validate the args
            candidates = [[]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('clear vnc', *args)
            raise ValidationError('could not understand command', args)
    

    
        def vyatta(self, *args):
            '''Resets state for vyatta. See "help vyatta" for more information.'''
            #validate the args
            candidates = [[]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('clear vyatta', *args)
            raise ValidationError('could not understand command', args)
    

    
        def log(self, *args):
            '''Resets state for logging. See "help log ..." for more information.'''
            #validate the args
            candidates = [[], [{'type': 'choiceItem', 'optional': False, 'options': ['file'], 'text': 'file,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['level'], 'text': 'level,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['stderr'], 'text': 'stderr,'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('clear log', *args)
            raise ValidationError('could not understand command', args)
    

    
        def capture(self, *args):
            '''Resets state for captures. See "help capture" for more information.'''
            #validate the args
            candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['netflow', 'pcap'], 'text': 'netflow,pcap'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('clear capture', *args)
            raise ValidationError('could not understand command', args)
    

    
        def history(self, *args):
            '''Reset the command history. See "help history" for more information.'''
            #validate the args
            candidates = [[]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('clear history', *args)
            raise ValidationError('could not understand command', args)
    

    
        class vm:
    
    
            def config(self, *args):
                '''Resets the configuration for a provided field (or the whole configuration) back
to the default value.'''
                #validate the args
                candidates = [[], [{'type': 'choiceItem', 'optional': False, 'options': ['append'], 'text': 'append,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['cdrom'], 'text': 'cdrom,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['disk'], 'text': 'disk,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['initrd'], 'text': 'initrd,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['kernel'], 'text': 'kernel,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['memory'], 'text': 'memory,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['net'], 'text': 'net,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['qemu'], 'text': 'qemu,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['qemu-append'], 'text': 'qemu-append,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['qemu-override'], 'text': 'qemu-override,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['snapshot'], 'text': 'snapshot,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['uuid'], 'text': 'uuid,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['vcpus'], 'text': 'vcpus,'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('clear vm config', *args)
                raise ValidationError('could not understand command', args)
    

    
            def tag(self, *args):
                '''Clears one, many, or all tags from a virtual machine.

Clear the tag "foo" from VM 0:

        clear vm tag 0 foo

Clear the tag "foo" from all VMs:

        clear vm tag all foo

Clear all tags from VM 0:

        clear vm tag 0

Clear all tags from all VMs:

        clear vm tag all'''
                #validate the args
                candidates = [[{'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'tag', 'type': 'stringItem', 'optional': True, 'key': 'tag'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('clear vm tag', *args)
                raise ValidationError('could not understand command', args)
    

    

    
        def tap(self, *args):
            '''Reset state for taps. See "help tap" for more information.'''
            #validate the args
            candidates = [[]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('clear tap', *args)
            raise ValidationError('could not understand command', args)
    

    
        def cc(self, *args):
            '''Resets state for the command and control infrastructure provided by minimega.
See "help cc" for more information.'''
            #validate the args
            candidates = [[], [{'type': 'choiceItem', 'optional': False, 'options': ['commands'], 'text': 'commands,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['filter'], 'text': 'filter,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['prefix'], 'text': 'prefix,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['responses'], 'text': 'responses,'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('clear cc', *args)
            raise ValidationError('could not understand command', args)
    

    

    
    def vnc(self, *args):
        '''Record or playback keyboard and mouse events sent via the web interface to the
selected VM.

With no arguments, vnc will list currently recording or playing VNC sessions.

If record is selected, a file will be created containing a record of mouse and
keyboard actions by the user.

If playback is selected, the specified file (created using vnc record) will be
read and processed as a sequence of time-stamped mouse/keyboard events to send
to the specified VM.'''
        #validate the args
        candidates = [[], [{'type': 'choiceItem', 'optional': False, 'options': ['kb', 'fb'], 'text': 'kb,fb'}, {'type': 'choiceItem', 'optional': False, 'options': ['record'], 'text': 'record,'}, {'text': 'host', 'type': 'stringItem', 'optional': False, 'key': 'host'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'filename', 'type': 'stringItem', 'optional': False, 'key': 'filename'}], [{'type': 'choiceItem', 'optional': False, 'options': ['kb', 'fb'], 'text': 'kb,fb'}, {'type': 'choiceItem', 'optional': False, 'options': ['norecord'], 'text': 'norecord,'}, {'text': 'host', 'type': 'stringItem', 'optional': False, 'key': 'host'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}], [{'type': 'choiceItem', 'optional': False, 'options': ['playback'], 'text': 'playback,'}, {'text': 'host', 'type': 'stringItem', 'optional': False, 'key': 'host'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'filename', 'type': 'stringItem', 'optional': False, 'key': 'filename'}], [{'type': 'choiceItem', 'optional': False, 'options': ['noplayback'], 'text': 'noplayback,'}, {'text': 'host', 'type': 'stringItem', 'optional': False, 'key': 'host'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('vnc', *args)
        raise ValidationError('could not understand command', args)
    

    
    def bridge(self, *args):
        '''display information about virtual bridges'''
        #validate the args
        candidates = [[]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('bridge', *args)
        raise ValidationError('could not understand command', args)
    

    
    def quit(self, *args):
        '''Quit. An optional integer argument X allows deferring the quit call for X
seconds. This is useful for telling a mesh of minimega nodes to quit.

quit will not return a response to the cli, control socket, or meshage, it will
simply exit. meshage connected nodes catch this and will remove the quit node
from the mesh. External tools interfacing minimega must check for EOF on stdout
or the control socket as an indication that minimega has quit.'''
        #validate the args
        candidates = [[{'text': 'delay', 'type': 'stringItem', 'optional': True, 'key': 'delay'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('quit', *args)
        raise ValidationError('could not understand command', args)
    

    
    def echo(self, *args):
        '''display text after macro expansion and comment removal'''
        #validate the args
        candidates = [[{'text': 'args', 'type': 'listItem', 'optional': True, 'key': 'args'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('echo', *args)
        raise ValidationError('could not understand command', args)
    

    
    def csv(self, *args):
        '''Enable or disable CSV mode. Enabling CSV mode disables JSON mode, if enabled.'''
        #validate the args
        candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['true', 'false'], 'text': 'true,false'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('.csv', *args)
        raise ValidationError('could not understand command', args)
    

    
    class mesh:
    
    
        def degree(self, *args):
            '''view or set the current degree for this mesh node'''
            #validate the args
            candidates = [[{'text': 'degree', 'type': 'stringItem', 'optional': True, 'key': 'degree'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('mesh degree', *args)
            raise ValidationError('could not understand command', args)
    

    
        def status(self, *args):
            '''display a short status report of the mesh'''
            #validate the args
            candidates = [[]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('mesh status', *args)
            raise ValidationError('could not understand command', args)
    

    
        def list(self, *args):
            '''display the mesh adjacency list'''
            #validate the args
            candidates = [[]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('mesh list', *args)
            raise ValidationError('could not understand command', args)
    

    
        def dot(self, *args):
            '''Output a graphviz formatted dot file representing the connected topology.'''
            #validate the args
            candidates = [[{'text': 'filename', 'type': 'stringItem', 'optional': False, 'key': 'filename'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('mesh dot', *args)
            raise ValidationError('could not understand command', args)
    

    
        def timeout(self, *args):
            '''View or set the timeout on sending mesh commands.

When a mesh command is issued, if a response isn't sent within mesh_timeout
seconds, the command will be dropped and any future response will be discarded.
Note that this does not cancel the outstanding command - the node receiving the
command may still complete - but rather this node will stop waiting on a
response.'''
            #validate the args
            candidates = [[{'text': 'timeout', 'type': 'stringItem', 'optional': True, 'key': 'timeout'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('mesh timeout', *args)
            raise ValidationError('could not understand command', args)
    

    
        def send(self, *args):
            '''Send a command to one or more connected clients. For example, to get the
vm info from nodes kn1 and kn2:

	mesh send kn[1-2] vm info

You can use 'all' to send a command to all connected clients.'''
            #validate the args
            candidates = [[{'text': 'vms or all', 'type': 'stringItem', 'optional': False, 'key': 'vms'}, {'text': 'command', 'type': 'commandItem', 'optional': False, 'key': 'command'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('mesh send', *args)
            raise ValidationError('could not understand command', args)
    

    
        def dial(self, *args):
            '''attempt to connect this node to another node'''
            #validate the args
            candidates = [[{'text': 'hostname', 'type': 'stringItem', 'optional': False, 'key': 'hostname'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('mesh dial', *args)
            raise ValidationError('could not understand command', args)
    

    
        def hangup(self, *args):
            '''disconnect from a client'''
            #validate the args
            candidates = [[{'text': 'hostname', 'type': 'stringItem', 'optional': False, 'key': 'hostname'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('mesh hangup', *args)
            raise ValidationError('could not understand command', args)
    

    

    
    def version(self, *args):
        '''display the minimega version'''
        #validate the args
        candidates = [[]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('version', *args)
        raise ValidationError('could not understand command', args)
    

    
    def cc(self, *args):
        '''Command and control virtual machines running the miniccc client. Commands may
include regular commands, backgrounded commands, and any number of sent and/or
received files. Commands will be executed in command creation order. For
example, to send a file 'foo' and display the contents on a remote VM:

	cc send=foo
	cc exec="cat foo"

Files to be sent must be in the filepath directory, as set -filepath

Responses are organized in a structure within <filepath>/miniccc_responses, and
include subdirectories for each client response named by the client's UUID.
Responses can also be displayed on the command line with the 'responses'
command. 

Filters may be set to limit which clients may execute a posted command.  For
example, to filter on VMs that are running windows and have a specific IP.

	cc filter os=windows ip=10.0.0.1 

New commands assign any current filter.'''
        #validate the args
        candidates = [[], [{'type': 'choiceItem', 'optional': False, 'options': ['start'], 'text': 'start,'}, {'text': 'port', 'type': 'stringItem', 'optional': True, 'key': 'port'}], [{'type': 'choiceItem', 'optional': False, 'options': ['serial'], 'text': 'serial,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['clients'], 'text': 'clients,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['prefix'], 'text': 'prefix,'}, {'text': 'prefix', 'type': 'stringItem', 'optional': True, 'key': 'prefix'}], [{'type': 'choiceItem', 'optional': False, 'options': ['send'], 'text': 'send,'}, {'text': 'file', 'type': 'listItem', 'optional': False, 'key': 'file'}], [{'type': 'choiceItem', 'optional': False, 'options': ['recv'], 'text': 'recv,'}, {'text': 'file', 'type': 'listItem', 'optional': False, 'key': 'file'}], [{'type': 'choiceItem', 'optional': False, 'options': ['exec'], 'text': 'exec,'}, {'text': 'command', 'type': 'listItem', 'optional': False, 'key': 'command'}], [{'type': 'choiceItem', 'optional': False, 'options': ['background'], 'text': 'background,'}, {'text': 'command', 'type': 'listItem', 'optional': False, 'key': 'command'}], [{'type': 'choiceItem', 'optional': False, 'options': ['commands'], 'text': 'commands,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['filter'], 'text': 'filter,'}, {'text': 'filter', 'type': 'listItem', 'optional': True, 'key': 'filter'}], [{'type': 'choiceItem', 'optional': False, 'options': ['responses'], 'text': 'responses,'}, {'text': 'id or prefix or all', 'type': 'stringItem', 'optional': False, 'key': 'id'}, {'type': 'choiceItem', 'optional': True, 'options': ['raw'], 'text': 'raw,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['delete'], 'text': 'delete,'}, {'type': 'choiceItem', 'optional': False, 'options': ['command'], 'text': 'command,'}, {'text': 'id or prefix or all', 'type': 'stringItem', 'optional': False, 'key': 'id'}], [{'type': 'choiceItem', 'optional': False, 'options': ['delete'], 'text': 'delete,'}, {'type': 'choiceItem', 'optional': False, 'options': ['response'], 'text': 'response,'}, {'text': 'id or prefix or all', 'type': 'stringItem', 'optional': False, 'key': 'id'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('cc', *args)
        raise ValidationError('could not understand command', args)
    

    
    def capture(self, *args):
        '''Capture experiment data including netflow and PCAP. Netflow capture obtains
netflow data from any local openvswitch switch, and can write to file, another
socket, or both. Netflow data can be written out in raw or ascii format, and
file output can be compressed on the fly. Multiple netflow writers can be
configured.

PCAP capture can be from a bridge or VM interface. No filters are applied, and
all data seen on that interface is captured to file.

For example, to capture netflow data on bridge mega_bridge to file in ascii
mode and with gzip compression:

	minimega$ capture netflow mega_bridge file foo.netflow ascii gzip

You can change the active flow timeout with:

	minimega$ capture netflow mega_bridge timeout <timeout>

With <timeout> in seconds.

To capture pcap on bridge 'foo' to file 'foo.pcap':

	minimega$ capture pcap bridge foo foo.pcap

To capture pcap on VM 'foo' to file 'foo.pcap', using the 2nd interface on that
VM:

	minimega$ capture pcap vm foo 0 foo.pcap'''
        #validate the args
        candidates = [[], [{'type': 'choiceItem', 'optional': False, 'options': ['netflow'], 'text': 'netflow,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['netflow'], 'text': 'netflow,'}, {'type': 'choiceItem', 'optional': False, 'options': ['timeout'], 'text': 'timeout,'}, {'text': 'timeout', 'type': 'stringItem', 'optional': True, 'key': 'timeout'}], [{'type': 'choiceItem', 'optional': False, 'options': ['netflow'], 'text': 'netflow,'}, {'text': 'bridge', 'type': 'stringItem', 'optional': False, 'key': 'bridge'}], [{'type': 'choiceItem', 'optional': False, 'options': ['netflow'], 'text': 'netflow,'}, {'text': 'bridge', 'type': 'stringItem', 'optional': False, 'key': 'bridge'}, {'type': 'choiceItem', 'optional': False, 'options': ['file'], 'text': 'file,'}, {'text': 'filename', 'type': 'stringItem', 'optional': False, 'key': 'filename'}], [{'type': 'choiceItem', 'optional': False, 'options': ['netflow'], 'text': 'netflow,'}, {'text': 'bridge', 'type': 'stringItem', 'optional': False, 'key': 'bridge'}, {'type': 'choiceItem', 'optional': False, 'options': ['file'], 'text': 'file,'}, {'text': 'filename', 'type': 'stringItem', 'optional': False, 'key': 'filename'}, {'type': 'choiceItem', 'optional': False, 'options': ['raw', 'ascii'], 'text': 'raw,ascii'}, {'text': 'gzip', 'type': 'stringItem', 'optional': True, 'key': 'gzip'}], [{'type': 'choiceItem', 'optional': False, 'options': ['netflow'], 'text': 'netflow,'}, {'text': 'bridge', 'type': 'stringItem', 'optional': False, 'key': 'bridge'}, {'type': 'choiceItem', 'optional': False, 'options': ['socket'], 'text': 'socket,'}, {'type': 'choiceItem', 'optional': False, 'options': ['tcp', 'udp'], 'text': 'tcp,udp'}, {'text': 'hostname:port', 'type': 'stringItem', 'optional': False, 'key': 'hostname:port'}, {'type': 'choiceItem', 'optional': False, 'options': ['raw', 'ascii'], 'text': 'raw,ascii'}], [{'type': 'choiceItem', 'optional': False, 'options': ['netflow'], 'text': 'netflow,'}, {'type': 'choiceItem', 'optional': False, 'options': ['delete'], 'text': 'delete,'}, {'text': 'id or all', 'type': 'stringItem', 'optional': False, 'key': 'id'}], [{'type': 'choiceItem', 'optional': False, 'options': ['pcap'], 'text': 'pcap,'}], [{'type': 'choiceItem', 'optional': False, 'options': ['pcap'], 'text': 'pcap,'}, {'type': 'literalItem', 'optional': False, 'text': 'bridge'}, {'text': 'bridge', 'type': 'stringItem', 'optional': False, 'key': 'bridge'}, {'text': 'filename', 'type': 'stringItem', 'optional': False, 'key': 'filename'}], [{'type': 'choiceItem', 'optional': False, 'options': ['pcap'], 'text': 'pcap,'}, {'type': 'literalItem', 'optional': False, 'text': 'vm'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'interface index', 'type': 'stringItem', 'optional': False, 'key': 'interface'}, {'text': 'filename', 'type': 'stringItem', 'optional': False, 'key': 'filename'}], [{'type': 'choiceItem', 'optional': False, 'options': ['pcap'], 'text': 'pcap,'}, {'type': 'choiceItem', 'optional': False, 'options': ['delete'], 'text': 'delete,'}, {'text': 'id or all', 'type': 'stringItem', 'optional': False, 'key': 'id'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('capture', *args)
        raise ValidationError('could not understand command', args)
    

    
    def shell(self, *args):
        '''Execute a command under the credentials of the running user.

Commands run until they complete or error, so take care not to execute a command
that does not return.'''
        #validate the args
        candidates = [[{'text': 'command', 'type': 'listItem', 'optional': False, 'key': 'command'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('shell', *args)
        raise ValidationError('could not understand command', args)
    

    
    def background(self, *args):
        '''Execute a command under the credentials of the running user.

Commands run in the background and control returns immediately. Any output is
logged.'''
        #validate the args
        candidates = [[{'text': 'command', 'type': 'listItem', 'optional': False, 'key': 'command'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('background', *args)
        raise ValidationError('could not understand command', args)
    

    
    def file(self, *args):
        '''File allows you to transfer and manage files served by minimega in the
directory set by the -filepath flag (default is 'base'/files).

To list files currently being served, issue the list command with a directory
relative to the served directory:

	file list /foo

Issuing "file list /" will list the contents of the served directory.

Files can be deleted with the delete command:

	file delete /foo

If a directory is given, the directory will be recursively deleted.

Files are transferred using the get command. When a get command is issued, the
node will begin searching for a file matching the path and name within the
mesh. If the file exists, it will be transferred to the requesting node. If
multiple different files exist with the same name, the behavior is undefined.
When a file transfer begins, control will return to minimega while the transfer
completes.

To see files that are currently being transferred, use the status command:

	file status'''
        #validate the args
        candidates = [[{'type': 'choiceItem', 'optional': False, 'options': ['list'], 'text': 'list,'}, {'text': 'path', 'type': 'stringItem', 'optional': True, 'key': 'path'}], [{'type': 'choiceItem', 'optional': False, 'options': ['get'], 'text': 'get,'}, {'text': 'file', 'type': 'stringItem', 'optional': False, 'key': 'file'}], [{'type': 'choiceItem', 'optional': False, 'options': ['delete'], 'text': 'delete,'}, {'text': 'file', 'type': 'stringItem', 'optional': False, 'key': 'file'}], [{'type': 'choiceItem', 'optional': False, 'options': ['status'], 'text': 'status,'}]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('file', *args)
        raise ValidationError('could not understand command', args)
    

    
    def debug(self, *args):
        '''display internal debug information'''
        #validate the args
        candidates = [[]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('debug', *args)
        raise ValidationError('could not understand command', args)
    

    
    def nuke(self, *args):
        '''After a crash, the VM state on the machine can be difficult to recover from.
Nuke attempts to kill all instances of QEMU, remove all taps and bridges, and
removes the temporary minimega state on the harddisk.'''
        #validate the args
        candidates = [[]]
        for candidate in candidates:
            argNum = 0
            valid = True
            try:
                for arg in candidate:
                    if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                        valid = False
                        break
                    if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                        valid = False
                        break
                    if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                        valid = False
                        break
                    if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                        valid = False
                        break
                    argNum += 1
            except IndexError:
                if not candidate[argNum]['optional']:
                   valid = False
                pass
            if valid:
                if args[argNum:]:
                    continue
                return self._send('nuke', *args)
        raise ValidationError('could not understand command', args)
    

    
    class vm:
    
    
        class config:
    
    
            def memory(self, *args):
                '''Set the amount of physical memory to allocate in megabytes.'''
                #validate the args
                candidates = [[{'text': 'memory in megabytes', 'type': 'stringItem', 'optional': True, 'key': 'memory'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config memory', *args)
                raise ValidationError('could not understand command', args)
    

    
            def snapshot(self, *args):
                '''Enable or disable snapshot mode when using disk images. When enabled, disks
images will be loaded in memory when run and changes will not be saved. This
allows a single disk image to be used for many VMs.'''
                #validate the args
                candidates = [[{'type': 'choiceItem', 'optional': True, 'options': ['true', 'false'], 'text': 'true,false'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config snapshot', *args)
                raise ValidationError('could not understand command', args)
    

    
            def qemuappend(self, *args):
                '''Add additional arguments to be passed to the QEMU instance. For example:
	vm config qemu-append -serial tcp:localhost:4001'''
                #validate the args
                candidates = [[{'text': 'argument', 'type': 'listItem', 'optional': True, 'key': 'argument'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config qemu-append', *args)
                raise ValidationError('could not understand command', args)
    

    
            def kernel(self, *args):
                '''Attach a kernel image to a VM. If set, QEMU will boot from this image instead
of any disk image.'''
                #validate the args
                candidates = [[{'text': 'path to kernel', 'type': 'stringItem', 'optional': True, 'key': 'path'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config kernel', *args)
                raise ValidationError('could not understand command', args)
    

    
            def qemu(self, *args):
                '''set the QEMU process to invoke. Relative paths are ok.'''
                #validate the args
                candidates = [[{'text': 'path to qemu', 'type': 'stringItem', 'optional': True, 'key': 'path'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config qemu', *args)
                raise ValidationError('could not understand command', args)
    

    
            def append(self, *args):
                '''Add an append string to a kernel set with vm kernel. Setting vm append without
using vm kernel will result in an error.

For example, to set a static IP for a linux VM:
	vm config append ip=10.0.0.5 gateway=10.0.0.1 netmask=255.255.255.0 dns=10.10.10.10'''
                #validate the args
                candidates = [[{'text': 'argument', 'type': 'listItem', 'optional': True, 'key': 'argument'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config append', *args)
                raise ValidationError('could not understand command', args)
    

    
            def uuid(self, *args):
                '''Set the UUID for a virtual machine. If not set, minimega will create a random
one when the VM is launched.'''
                #validate the args
                candidates = [[{'text': 'uuid', 'type': 'stringItem', 'optional': True, 'key': 'uuid'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config uuid', *args)
                raise ValidationError('could not understand command', args)
    

    
            def cdrom(self, *args):
                '''Attach a cdrom to a VM. When using a cdrom, it will automatically be set to be
the boot device.'''
                #validate the args
                candidates = [[{'text': 'path to cdrom image', 'type': 'stringItem', 'optional': True, 'key': 'path'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config cdrom', *args)
                raise ValidationError('could not understand command', args)
    

    
            def initrd(self, *args):
                '''Attach an initrd image to a VM. Passed along with the kernel image at boot
time.'''
                #validate the args
                candidates = [[{'text': 'path to initrd', 'type': 'stringItem', 'optional': True, 'key': 'path'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config initrd', *args)
                raise ValidationError('could not understand command', args)
    

    
            def qemuoverride(self, *args):
                '''Override parts of the QEMU launch string by supplying a string to match, and a
replacement string.'''
                #validate the args
                candidates = [[], [{'type': 'literalItem', 'optional': False, 'text': 'add'}, {'text': 'match', 'type': 'stringItem', 'optional': False, 'key': 'match'}, {'text': 'replacement', 'type': 'stringItem', 'optional': False, 'key': 'replacement'}], [{'type': 'literalItem', 'optional': False, 'text': 'delete'}, {'text': 'id or all', 'type': 'stringItem', 'optional': False, 'key': 'id'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config qemu-override', *args)
                raise ValidationError('could not understand command', args)
    

    
            def net(self, *args):
                '''Specify the network(s) that the VM is a member of by VLAN. A corresponding VLAN
will be created for each network. Optionally, you may specify the bridge the
interface will be connected on. If the bridge name is omitted, minimega will
use the default 'mega_bridge'. You can also optionally specify the mac address
of the interface to connect to that network. If not specifed, the mac address
will be randomly generated. Additionally, you can optionally specify a driver
for qemu to use. By default, e1000 is used.

Examples:

To connect a VM to VLANs 1 and 5:
	vm config net 1 5
To connect a VM to VLANs 100, 101, and 102 with specific mac addresses:
	vm config net 100,00:00:00:00:00:00 101,00:00:00:00:01:00 102,00:00:00:00:02:00
To connect a VM to VLAN 1 on bridge0 and VLAN 2 on bridge1:
	vm config net bridge0,1 bridge1,2
To connect a VM to VLAN 100 on bridge0 with a specific mac:
	vm config net bridge0,100,00:11:22:33:44:55
To specify a specific driver, such as i82559c:
	vm config net 100,i82559c

Calling vm net with no parameters will list the current networks for this VM.'''
                #validate the args
                candidates = [[{'text': 'netspec', 'type': 'listItem', 'optional': True, 'key': 'netspec'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config net', *args)
                raise ValidationError('could not understand command', args)
    

    
            def vcpus(self, *args):
                '''Set the number of virtual CPUs to allocate for a VM.'''
                #validate the args
                candidates = [[{'text': 'number of CPUs', 'type': 'stringItem', 'optional': True, 'key': 'number'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config vcpus', *args)
                raise ValidationError('could not understand command', args)
    

    
            def disk(self, *args):
                '''Attach one or more disks to a vm. Any disk image supported by QEMU is a valid
parameter. Disk images launched in snapshot mode may safely be used for
multiple VMs.'''
                #validate the args
                candidates = [[{'text': 'path to disk image', 'type': 'listItem', 'optional': True, 'key': 'path'}]]
                for candidate in candidates:
                    argNum = 0
                    valid = True
                    try:
                        for arg in candidate:
                            if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                                valid = False
                                break
                            if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                                valid = False
                                break
                            if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                                valid = False
                                break
                            if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                                valid = False
                                break
                            argNum += 1
                    except IndexError:
                        if not candidate[argNum]['optional']:
                           valid = False
                        pass
                    if valid:
                        if args[argNum:]:
                            continue
                        return self._send('vm config disk', *args)
                raise ValidationError('could not understand command', args)
    

    

    
        def flush(self, *args):
            '''Discard information about VMs that have either quit or encountered an error.
This will remove any VMs with a state of "quit" or "error" from vm info. Names
of VMs that have been flushed may be reused.'''
            #validate the args
            candidates = [[]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm flush', *args)
            raise ValidationError('could not understand command', args)
    

    
        def info(self, *args):
            '''Print information about VMs. vm info allows searching for VMs based on any VM
parameter, and output some or all information about the VMs in question.
Additionally, you can display information about all running VMs.

A vm info command takes two optional arguments: a search term and an output
mask. If the search term is omitted, information about all VMs will be
displayed. If the output mask is omitted, all information about the VMs will be
displayed.

The search term uses a single key=value argument. For example, if you want all
information about VM 50:

	vm info search id=50

The output mask uses an ordered comma-seperated list of fields. For example, if
you want the ID and IPs for all VMs on vlan 100:

	vm info search vlan=100 mask id,ip

Searchable and maskable fields are:

- id	    : the VM ID, as an integer
- host	    : the host that the VM is running on
- name	    : the VM name, if it exists
- state     : one of (building, running, paused, quit, error)
- memory    : allocated memory, in megabytes
- vcpus     : the number of allocated CPUs
- disk      : disk image
- initrd    : initrd image
- kernel    : kernel image
- cdrom     : cdrom image
- append    : kernel command line string
- bridge    : bridge name
- tap	    : tap name
- mac	    : mac address
- ip	    : IPv4 address
- ip6	    : IPv6 address
- vlan	    : vlan, as an integer
- uuid      : QEMU system uuid
- cc_active : whether cc is active
- tags      : any additional information attached to the VM

Examples:

Display a list of all IPs for all VMs:
	vm info masks ip,ip6

Display all information about VMs with the disk image foo.qc2:
	vm info search disk=foo.qc2

Display all information about all VMs:
	vm info'''
            #validate the args
            candidates = [[], [{'type': 'literalItem', 'optional': False, 'text': 'search'}, {'text': 'terms', 'type': 'stringItem', 'optional': False, 'key': 'terms'}], [{'type': 'literalItem', 'optional': False, 'text': 'search'}, {'text': 'terms', 'type': 'stringItem', 'optional': False, 'key': 'terms'}, {'type': 'literalItem', 'optional': False, 'text': 'mask'}, {'text': 'masks', 'type': 'stringItem', 'optional': False, 'key': 'masks'}], [{'type': 'literalItem', 'optional': False, 'text': 'mask'}, {'text': 'masks', 'type': 'stringItem', 'optional': False, 'key': 'masks'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm info', *args)
            raise ValidationError('could not understand command', args)
    

    
        def inject(self, *args):
            '''Create a backed snapshot of a qcow2 image and injects one or more files into
the new snapshot.

src qcow image - the name of the qcow to use as the backing image file.

partition - The optional partition number in which the files should be
injected. Partition defaults to 1, but if multiple partitions exist and
partition is not explicitly specified, an error is thrown and files are not
injected.

dst qcow image name - The optional name of the snapshot image. This should be a
name only, if any extra path is specified, an error is thrown. This file will
be created at 'base'/files. A filename will be generated if this optional
parameter is omitted.

src file - The local file that should be injected onto the new qcow2 snapshot.

dst file - The path where src file should be injected in the new qcow2 snapshot.

If the src file or dst file contains spaces, use double quotes (" ") as in the
following example:

	vm inject src src.qc2 dst.qc2 "my file":"Program Files/my file"

Alternatively, when given a single argument, this command supplies the name of
the backing qcow image for a snapshot image.'''
            #validate the args
            candidates = [[{'type': 'literalItem', 'optional': False, 'text': 'src'}, {'text': 'srcimg', 'type': 'stringItem', 'optional': False, 'key': 'srcimg'}, {'text': 'files like /path/to/src:/path/to/dst', 'type': 'listItem', 'optional': False, 'key': 'files'}], [{'type': 'literalItem', 'optional': False, 'text': 'dst'}, {'text': 'dstimg', 'type': 'stringItem', 'optional': False, 'key': 'dstimg'}, {'type': 'literalItem', 'optional': False, 'text': 'src'}, {'text': 'srcimg', 'type': 'stringItem', 'optional': False, 'key': 'srcimg'}, {'text': 'files like /path/to/src:/path/to/dst', 'type': 'listItem', 'optional': False, 'key': 'files'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm inject', *args)
            raise ValidationError('could not understand command', args)
    

    
        def qmp(self, *args):
            '''Issue a JSON-encoded QMP command. This is a convenience function for accessing
the QMP socket of a VM via minimega. vm qmp takes two arguments, a VM ID or
name, and a JSON string, and returns the JSON encoded response. For example:

	minimega$ vm qmp 0 '{ "execute": "query-status" }'
	{"return":{"running":false,"singlestep":false,"status":"prelaunch"}}'''
            #validate the args
            candidates = [[{'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'qmp command', 'type': 'stringItem', 'optional': False, 'key': 'qmp'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm qmp', *args)
            raise ValidationError('could not understand command', args)
    

    
        def stop(self, *args):
            '''Stop one or all running virtual machines. Pass all to stop all running virtual
machines.

Calling stop will put VMs in a paused state. Start stopped VMs with vm start.'''
            #validate the args
            candidates = [[{'text': 'vm id or name or all', 'type': 'stringItem', 'optional': False, 'key': 'vm'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm stop', *args)
            raise ValidationError('could not understand command', args)
    

    
        def save(self, *args):
            '''Saves the configuration of a running virtual machine or set of virtual machines
so that it/they can be restarted/recovered later, such as after a system crash.

If no VM name or ID is given, all VMs (including those in the quit and error
state) will be saved.

This command does not store the state of the virtual machine itself, only its
launch configuration.'''
            #validate the args
            candidates = [[{'text': 'name', 'type': 'stringItem', 'optional': False, 'key': 'name'}, {'text': 'vm id or name or all', 'type': 'listItem', 'optional': False, 'key': 'vm'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm save', *args)
            raise ValidationError('could not understand command', args)
    

    
        def launch(self, *args):
            '''Launch virtual machines in a paused state, using the parameters defined leading
up to the launch command. Any changes to the VM parameters after launching will
have no effect on launched VMs.

If you supply a name instead of a number of VMs, one VM with that name will be
launched. You may also supply a range expression to launch VMs with a specific
naming scheme:

	vm launch foo[0-9]

The optional 'noblock' suffix forces minimega to return control of the command
line immediately instead of waiting on potential errors from launching the
VM(s). The user must check logs or error states from vm info.'''
            #validate the args
            candidates = [[{'text': 'name or count', 'type': 'stringItem', 'optional': False, 'key': 'name'}, {'type': 'choiceItem', 'optional': True, 'options': ['noblock'], 'text': 'noblock,'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm launch', *args)
            raise ValidationError('could not understand command', args)
    

    
        def hotplug(self, *args):
            '''Add and remove USB drives to a launched VM.

To view currently attached media, call vm hotplug with the 'show' argument and
a VM ID or name. To add a device, use the 'add' argument followed by the VM ID
or name, and the name of the file to add. For example, to add foo.img to VM 5:

	vm hotplug add 5 foo.img

The add command will assign a disk ID, shown in vm hotplug show. To remove
media, use the 'remove' argument with the VM ID and the disk ID. For example,
to remove the drive added above, named 0:

	vm hotplug remove 5 0

To remove all hotplug devices, use ID * for the disk ID.'''
            #validate the args
            candidates = [[{'type': 'choiceItem', 'optional': False, 'options': ['show'], 'text': 'show,'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}], [{'type': 'choiceItem', 'optional': False, 'options': ['add'], 'text': 'add,'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'filename', 'type': 'stringItem', 'optional': False, 'key': 'filename'}], [{'type': 'choiceItem', 'optional': False, 'options': ['remove'], 'text': 'remove,'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'disk id or all', 'type': 'stringItem', 'optional': False, 'key': 'disk'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm hotplug', *args)
            raise ValidationError('could not understand command', args)
    

    
        def tag(self, *args):
            '''Display or set a tag for the specified VM.

Tags are key-value pairs. A VM can have any number of tags associated
with it. They can be used to attach additional information to a
virtual machine, for example specifying a VM "group", or the correct
rendering color for some external visualization tool.

To set a tag:

        vm tag <vm id or name> <key> [value]

To read a tag:

        vm tag <vm id or name> <key>

Tags are not displayed in "vm info" by default, as there may be many of them.'''
            #validate the args
            candidates = [[{'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'key', 'type': 'stringItem', 'optional': False, 'key': 'key'}, {'text': 'value', 'type': 'stringItem', 'optional': True, 'key': 'value'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm tag', *args)
            raise ValidationError('could not understand command', args)
    

    
        def cdrom(self, *args):
            '''Eject or change an active VM's cdrom image.

Eject VM 0's cdrom:

        vm cdrom eject 0

Eject all VM cdroms:

        vm cdrom eject all

Change a VM to use a new ISO:

        vm cdrom change 0 /tmp/debian.iso

"vm change" implies that the current ISO will be ejected.'''
            #validate the args
            candidates = [[{'type': 'choiceItem', 'optional': False, 'options': ['eject'], 'text': 'eject,'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}], [{'type': 'choiceItem', 'optional': False, 'options': ['change'], 'text': 'change,'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'path', 'type': 'stringItem', 'optional': False, 'key': 'path'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm cdrom', *args)
            raise ValidationError('could not understand command', args)
    

    
        def net(self, *args):
            '''Disconnect or move existing network connections on a running VM.

Network connections are indicated by their position in vm net (same order in vm
info) and are zero indexed. For example, to disconnect the first network
connection from a VM named vm-0 with 4 network connections:

	vm netmod disconnect vm-0 0

To disconnect the second connection:

	vm netmod disconnect vm-0 1

To move a connection, specify the new VLAN tag and bridge:

	vm netmod <vm name or id> 0 bridgeX 100'''
            #validate the args
            candidates = [[{'type': 'choiceItem', 'optional': False, 'options': ['connect'], 'text': 'connect,'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'tap position', 'type': 'stringItem', 'optional': False, 'key': 'tap'}, {'text': 'bridge', 'type': 'stringItem', 'optional': False, 'key': 'bridge'}, {'text': 'vlan', 'type': 'stringItem', 'optional': False, 'key': 'vlan'}], [{'type': 'choiceItem', 'optional': False, 'options': ['disconnect'], 'text': 'disconnect,'}, {'text': 'vm id or name', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'text': 'tap position', 'type': 'stringItem', 'optional': False, 'key': 'tap'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm net', *args)
            raise ValidationError('could not understand command', args)
    

    
        def kill(self, *args):
            '''Kill a virtual machine by ID or name. Pass all to kill all virtual machines.'''
            #validate the args
            candidates = [[{'text': 'vm id or name or all', 'type': 'stringItem', 'optional': False, 'key': 'vm'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm kill', *args)
            raise ValidationError('could not understand command', args)
    

    
        def start(self, *args):
            '''Start one or all paused virtual machines. Pass all to start all paused virtual
machines.

Calling vm start specifically on a quit VM will restart the VM. If the optional 'quit'
suffix is used with the wildcard, then all virtual machines in the paused *or* quit state
will be restarted.'''
            #validate the args
            candidates = [[{'text': 'vm id or name or all', 'type': 'stringItem', 'optional': False, 'key': 'vm'}, {'type': 'choiceItem', 'optional': True, 'options': ['quit'], 'text': 'quit,'}]]
            for candidate in candidates:
                argNum = 0
                valid = True
                try:
                    for arg in candidate:
                        if arg['type'] == 'stringItem' and not _isstr(args[argNum]):
                            valid = False
                            break
                        if arg['type'] == 'listItem' and not isinstance(args[argNum], list):
                            valid = False
                            break
                        if arg['type'] == 'commandItem' and not isinstance(args[argNum], Command):
                            valid = False
                            break
                        if arg['type'] == 'choiceItem' and args[argNum] not in arg['choices']:
                            valid = False
                            break
                        argNum += 1
                except IndexError:
                    if not candidate[argNum]['optional']:
                       valid = False
                    pass
                if valid:
                    if args[argNum:]:
                        continue
                    return self._send('vm start', *args)
            raise ValidationError('could not understand command', args)
    

    

