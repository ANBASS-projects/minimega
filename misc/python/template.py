'''
Copyright (2015) Sandia Corporation.
Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
the U.S. Government retains certain rights in this software.

Devin Cook <devcook@sandia.gov>

Minimega bindings for Python

**************************************************************************
* THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY THIS FILE BY HAND. *
**************************************************************************

This API uses a Unix domain socket to communicate with a running instance of
minimega. The protocol is documented here:
https://code.google.com/p/minimega/wiki/UserGuide#Command_Port_and_the_Local_Command_Flag

This file is automatically generated from the output of "minimega -cli". See
the documentation for genapi.py for details on how to regenerate this file.

This API *should* work for both python2.7 and python3. Please report any issues
to the bug tracker:
https://code.google.com/p/minimega/issues/list
'''


import json
import socket
from threading import Lock


# This version is specific to the python API. It is not indicative of the
#  versions of minimega that it can talk with.
__version__ = '{{ version }}'


class Error(Exception): pass
class ValidationError(Error): pass


DEFAULT_TIMEOUT = 60
MSG_BLOCK_SIZE = 4096


def connect(path):
    '''
    Connect to the minimega instance with UNIX socket at <path> and return
    a new minimega API object.
    '''
    return minimega(path)


class minimega:
    '''
    This class communicates with a running instance of minimega using a Unix
    domain socket. The protocol is specified here:
    https://code.google.com/p/minimega/wiki/UserGuide#Command_Port_and_the_Local_Command_Flag

    Each minimega command can be called from this object, and the response will
    be returned unless an Exception is thrown.
    '''

    def __init__(self, path, timeout=None):
        '''Connects to the minimega instance with Unix socket at <path>.'''
        self.lock = Lock()
        self._debug = False
        self._path = path
        self._timeout = timeout
        self._socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self._socket.settimeout(timeout if timeout != None else DEFAULT_TIMEOUT)
        self._socket.connect(path)

    def _reconnect(self):
        try:
            self._socket.close()
        except:
            pass

        self.__init__(self._path, self._timeout)

    def _send(self, cmd, *args):
        with self.lock:
            msg = json.dumps({'Command': cmd, 'Args': args},
                             separators=(',', ':'))
            if len(msg) != self._socket.send(msg.encode('utf-8')):
                raise Error('failed to write message to minimega')

            msg = ''
            more = self._socket.recv(MSG_BLOCK_SIZE).decode('utf-8')
            response = None
            while response is None and more:
                msg += more
                try:
                    response = json.loads(msg)
                except ValueError as e:
                    if self._debug:
                        print(e)
                    more = self._socket.recv(MSG_BLOCK_SIZE).decode('utf-8')

            if not msg:
                raise Error('Expected response, socket closed')

            if response['Error']:
                raise Error(response['Error'])

            return response['Response']

{% for cmd, info in cmds.items() recursive %}
    {% if info.subcommands %}
{{ '    ' * loop.depth }}class {{ cmd }}:
    {{ loop(info.subcommands.items()) }}
    {% else %}
{{ '    ' * loop.depth }}def {{ cmd }}(*args):
    {{ '    ' * loop.depth }}'''{{ info.help_long or info.help_short}}'''
    {{ '    ' * loop.depth }}pass
    {% endif %}
{% endfor %}

